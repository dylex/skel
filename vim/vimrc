set   autoindent
set   backspace=2
set nobackup
set   backupskip=/tmp/*,/var/tmp/*
"set   cindent
set   cinkeys-=0#
set   cpoptions-=s
set   diffopt=filler,iwhite,vertical
set noequalalways
"set equalprg=indent
set   fileformats=unix,dos,mac
set   foldmethod=indent
set   foldlevelstart=63
set   formatoptions=rq
set nohlsearch
set   ignorecase
set   incsearch
"set   langmap=tjjtnkksslln
set   laststatus=2
if $OSTYPE =~? 'freebsd'
set   makeprg=gmake
endif
set   matchpairs+=<:>
set   modeline
set   mouse=a
set   number
set   ruler
set   scrolloff=5
set   selection=exclusive
set   shiftwidth=8
set   showcmd
set   showmatch
set   sidescroll=1
set   smartcase
"set   smartindent
if has('spell')
set   spelllang=en_us
endif
set   splitright
set nostartofline
set   statusline=%2n\ %f%=%<\ %(%Y%W%H%R%M%)\ \ %P\ %10(%c%V%),%-6l\ %7o=%02B
set   suffixes-=.h
set   switchbuf=useopen,usetab
set   tabstop=8
set   textwidth=0
set   timeoutlen=2000
set   ttimeoutlen=100
if has('persistent_undo')
set   undodir=/tmp/vimundo-$USER
set   undofile
au BufWritePre /tmp/* setl noundofile
au BufWritePre /var/tmp/* setl noundofile
endif
set   viminfo='12,h,%,n~/.vim/viminfo
set   whichwrap=b,s,<,>,[,]
set   wrap

if $QWERTY == ""
no t j
no n k
no s l
no - t
no j +
no k -
no l n
no t j
no n k
no s l
no j n
no k t
no l s
no T J
no N K
no S L
no K T
endif

let netrw_list_hide='^\.'
let netrw_http_cmd="curl -o"

let mapleader = ""
map!  <BS>
map!  <BS>
map Y y$
map ZW :up<CR>
nmap q: :q
nmap Q :confirm q<CR>
nmap <Leader>p :set paste<CR>
nmap <Leader>u :set nopaste<CR>
nmap <Leader>m :up<CR>:make<CR>
if has('spell')
	nmap <Leader>/ :set spell<CR>
	nmap <Leader>c :set nospell<CR>
	"nmap <Leader>n normal ]s
	"nmap <Leader>r normal [s
	"nmap <Leader>- normal z=
	"nmap <Leader>, normal zg
else
	let spell_language_list = "en_US"
	let spell_executable = "aspell"
	let spell_options = "-W 2"
	let spell_auto_type = ""
	nmap <silent> <unique>          <Leader>/ <Plug>SpellCheck
	nmap <silent> <unique>          <Leader>- <Plug>SpellProposeAlternatives
	let spell_exit_map =            "\<Leader>c"
	let spell_next_error_map =      "\<Leader>n"
	let spell_previous_error_map =  "\<Leader>r"
	let spell_ignore_map =          "\<Leader>."
	let spell_accept_map =          "\<Leader>,"
	let spell_case_accept_map =     "\<Leader>'"
endif
let c_gnu=1
let c_no_curly_error=1

nmap \l :call LineUpPrevWord()<CR>
nmap \r :call LineUpNextWord()<CR>

com -range=% StripTrailing <line1>,<line2>s:\s\+$::
nmap <Leader>s :StripTrailing<CR>
vmap <Leader>s :StripTrailing<CR>

nmap <Leader>2 :<C-u>let @z=&so<CR>:set so=0 noscb<CR>:bo vs<CR>Ljzt:setl scb<CR><C-w>p:setl scb<CR>:let &so=@z<CR>

if hostname() =~ '^druid\.'
	nmap <Leader>y :call SyncSources()<CR>
	set tags+=~/cvs/current/tags
endif

fun OCamlSetup ()
	setl sw=2
	setl sts=2
	setl errorformat+=%-Gocaml%m,%AFile\ \"%f\"\\,\ line\ %l\\,\ characters\ %c-%*\\d:,%-Zmake:\ ***\ [%f]\ Error\ %n\,%C%m
	set   suffixes+=.cmi,.cmo,.cmx
endfun

fun HaskellSetup ()
	setl sw=2
	setl sts=2
	setl et
	setl errorformat+=%-Gghc%m,
		\%-G[%\\d%#\ of\ %\\d%#]\ Compiling\ %.%#\ (\ %f\\,\ %.%#\ ),
		\%-GLinking\ %.%#,
		\Loading\ package\ %.%#,
		\%f:%l:%c:\ %m,
		\%A%f:%l:%c:,
		\%+C\ \ %#%m,
		\%-Gmake:\ ***\ [%f]\ Error\ %n,
		\%-G
	setl matchpairs-=<:>
	setf haskell
	set   suffixes+=.hi
endfun

fun TextSetup ()
	setl fo+=t
	setl nocindent
	setl nosmartindent
	setl textwidth=78
	setl et
	setl errorformat+=%E!\ LaTeX\ %trror:\ %m,
		\%E!\ %m,
		\%+WLaTeX\ %.%#Warning:\ %.%#line\ %l%.%#,
		\%+W%.%#\ at\ lines\ %l--%*\\d,
		\%WLaTeX\ %.%#Warning:\ %m,
		\%Cl.%l\ %m,
		\%+C\ \ %m.,
		\%+C%.%#-%.%#,
		\%+C%.%#[]%.%#,
		\%+C[]%.%#,
		\%+C%.%#%[{}\\]%.%#,
		\%+C<%.%#>%.%#,
		\%C\ \ %m,
		\%-GSee\ the\ LaTeX%m,
		\%-GType\ \ H\ <return>%m,
		\%-G\ ...%.%#,
		\%-G%.%#\ (C)\ %.%#,
		\%-G(see\ the\ transcript%.%#),
		\%-G\\s%#,
		\%+O(%f)%r,
		\%+P(%f%r,
		\%+P\ %\\=(%f%r,
		\%+P%*[^()](%f%r,
		\%+P[%\\d%[^()]%#(%f%r,
		\%+Q)%r,
		\%+Q%*[^()])%r,
		\%+Q[%\\d%*[^()])%r
	if has('spell')
		setl spell
	endif
endfun

fun MailSetup ()
	call TextSetup()
	if match(getline(2), '^To: bugs') == 0 && match(getline(5), '^Subject: .*\[Bug') == 0
		5s/^Subject: .*\(\[Bug \d*\]\).*/Subject: \1/
	endif
endfun

fun TexSetup ()
	setl nocindent
	setl matchpairs+=`:'
	if has('spell')
		setl spell
	endif
	set   suffixes+=.aux,.log,.dvi,.ps,.pdf
endfun

fun CodeSetup ()
	setl cindent
	setl smartindent
	if hostname() =~ '\.\(rainfinity\|emc\)\.com$'
		setl sts=2
		setl sw=2
	endif
endfun

fun MatlabSetup ()
	call CodeSetup ()
	setl sts=4
	setl sw=4
	setl et
endfun

fun M4Setup ()
	setl matchpairs+=`:'
endfun

autocmd BufNewFile,BufRead *.ml* call OCamlSetup()
autocmd BufNewFile,BufRead *.hs* call HaskellSetup()
autocmd BufNewFile,BufRead DOC call TextSetup()
autocmd BufNewFile,BufRead *.r,*.R setf r
autocmd BufNewFile,BufRead *.hsc setf chaskell
autocmd BufNewFile,BufRead *.gnuplot setf gnuplot
autocmd FileType mail call MailSetup()
autocmd FileType tex call TexSetup()
autocmd FileType c,cpp call CodeSetup()
autocmd FileType *m4 call M4Setup()
autocmd FileType matlab call MatlabSetup()
autocmd FileType mp setl indentkeys= " metapost indenting sucks
autocmd BufReadPost * exe "normal `\""

if $TERM =~ '^\(screen\.\)\?\(screen\|m\?rxvt\|xterm-xfree86\|connectbot\)\(-256color\)\?$'
	set t_Co=256
endif

filetype on
syntax on
colorscheme my
filetype indent on

if filereadable($MYVIMRC . ".local")
	source $MYVIMRC.local
endif
